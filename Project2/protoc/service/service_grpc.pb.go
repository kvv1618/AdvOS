// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.15.8
// source: service.proto

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JobService_JobDetails_FullMethodName = "/service.JobService/JobDetails"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobServiceClient interface {
	JobDetails(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JobDetailsResponse, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) JobDetails(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JobDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobDetailsResponse)
	err := c.cc.Invoke(ctx, JobService_JobDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility.
type JobServiceServer interface {
	JobDetails(context.Context, *Empty) (*JobDetailsResponse, error)
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobServiceServer struct{}

func (UnimplementedJobServiceServer) JobDetails(context.Context, *Empty) (*JobDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JobDetails not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}
func (UnimplementedJobServiceServer) testEmbeddedByValue()                    {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_JobDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).JobDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_JobDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).JobDetails(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JobDetails",
			Handler:    _JobService_JobDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	JobDataService_JobData_FullMethodName = "/service.JobDataService/JobData"
)

// JobDataServiceClient is the client API for JobDataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobDataServiceClient interface {
	JobData(ctx context.Context, in *JobDetailsResponse, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobDataResponse], error)
}

type jobDataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobDataServiceClient(cc grpc.ClientConnInterface) JobDataServiceClient {
	return &jobDataServiceClient{cc}
}

func (c *jobDataServiceClient) JobData(ctx context.Context, in *JobDetailsResponse, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobDataResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobDataService_ServiceDesc.Streams[0], JobDataService_JobData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[JobDetailsResponse, JobDataResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobDataService_JobDataClient = grpc.ServerStreamingClient[JobDataResponse]

// JobDataServiceServer is the server API for JobDataService service.
// All implementations must embed UnimplementedJobDataServiceServer
// for forward compatibility.
type JobDataServiceServer interface {
	JobData(*JobDetailsResponse, grpc.ServerStreamingServer[JobDataResponse]) error
	mustEmbedUnimplementedJobDataServiceServer()
}

// UnimplementedJobDataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobDataServiceServer struct{}

func (UnimplementedJobDataServiceServer) JobData(*JobDetailsResponse, grpc.ServerStreamingServer[JobDataResponse]) error {
	return status.Errorf(codes.Unimplemented, "method JobData not implemented")
}
func (UnimplementedJobDataServiceServer) mustEmbedUnimplementedJobDataServiceServer() {}
func (UnimplementedJobDataServiceServer) testEmbeddedByValue()                        {}

// UnsafeJobDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobDataServiceServer will
// result in compilation errors.
type UnsafeJobDataServiceServer interface {
	mustEmbedUnimplementedJobDataServiceServer()
}

func RegisterJobDataServiceServer(s grpc.ServiceRegistrar, srv JobDataServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobDataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobDataService_ServiceDesc, srv)
}

func _JobDataService_JobData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JobDetailsResponse)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobDataServiceServer).JobData(m, &grpc.GenericServerStream[JobDetailsResponse, JobDataResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobDataService_JobDataServer = grpc.ServerStreamingServer[JobDataResponse]

// JobDataService_ServiceDesc is the grpc.ServiceDesc for JobDataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobDataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.JobDataService",
	HandlerType: (*JobDataServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "JobData",
			Handler:       _JobDataService_JobData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	CondenseResultsService_CondenseResults_FullMethodName = "/service.CondenseResultsService/CondenseResults"
)

// CondenseResultsServiceClient is the client API for CondenseResultsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CondenseResultsServiceClient interface {
	CondenseResults(ctx context.Context, in *PartialResults, opts ...grpc.CallOption) (*Empty, error)
}

type condenseResultsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCondenseResultsServiceClient(cc grpc.ClientConnInterface) CondenseResultsServiceClient {
	return &condenseResultsServiceClient{cc}
}

func (c *condenseResultsServiceClient) CondenseResults(ctx context.Context, in *PartialResults, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CondenseResultsService_CondenseResults_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CondenseResultsServiceServer is the server API for CondenseResultsService service.
// All implementations must embed UnimplementedCondenseResultsServiceServer
// for forward compatibility.
type CondenseResultsServiceServer interface {
	CondenseResults(context.Context, *PartialResults) (*Empty, error)
	mustEmbedUnimplementedCondenseResultsServiceServer()
}

// UnimplementedCondenseResultsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCondenseResultsServiceServer struct{}

func (UnimplementedCondenseResultsServiceServer) CondenseResults(context.Context, *PartialResults) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CondenseResults not implemented")
}
func (UnimplementedCondenseResultsServiceServer) mustEmbedUnimplementedCondenseResultsServiceServer() {
}
func (UnimplementedCondenseResultsServiceServer) testEmbeddedByValue() {}

// UnsafeCondenseResultsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CondenseResultsServiceServer will
// result in compilation errors.
type UnsafeCondenseResultsServiceServer interface {
	mustEmbedUnimplementedCondenseResultsServiceServer()
}

func RegisterCondenseResultsServiceServer(s grpc.ServiceRegistrar, srv CondenseResultsServiceServer) {
	// If the following call pancis, it indicates UnimplementedCondenseResultsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CondenseResultsService_ServiceDesc, srv)
}

func _CondenseResultsService_CondenseResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartialResults)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CondenseResultsServiceServer).CondenseResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CondenseResultsService_CondenseResults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CondenseResultsServiceServer).CondenseResults(ctx, req.(*PartialResults))
	}
	return interceptor(ctx, in, info, handler)
}

// CondenseResultsService_ServiceDesc is the grpc.ServiceDesc for CondenseResultsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CondenseResultsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.CondenseResultsService",
	HandlerType: (*CondenseResultsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CondenseResults",
			Handler:    _CondenseResultsService_CondenseResults_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	StopConsolidatorService_StopConsolidator_FullMethodName = "/service.StopConsolidatorService/StopConsolidator"
)

// StopConsolidatorServiceClient is the client API for StopConsolidatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StopConsolidatorServiceClient interface {
	StopConsolidator(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type stopConsolidatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStopConsolidatorServiceClient(cc grpc.ClientConnInterface) StopConsolidatorServiceClient {
	return &stopConsolidatorServiceClient{cc}
}

func (c *stopConsolidatorServiceClient) StopConsolidator(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, StopConsolidatorService_StopConsolidator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StopConsolidatorServiceServer is the server API for StopConsolidatorService service.
// All implementations must embed UnimplementedStopConsolidatorServiceServer
// for forward compatibility.
type StopConsolidatorServiceServer interface {
	StopConsolidator(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedStopConsolidatorServiceServer()
}

// UnimplementedStopConsolidatorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStopConsolidatorServiceServer struct{}

func (UnimplementedStopConsolidatorServiceServer) StopConsolidator(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopConsolidator not implemented")
}
func (UnimplementedStopConsolidatorServiceServer) mustEmbedUnimplementedStopConsolidatorServiceServer() {
}
func (UnimplementedStopConsolidatorServiceServer) testEmbeddedByValue() {}

// UnsafeStopConsolidatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StopConsolidatorServiceServer will
// result in compilation errors.
type UnsafeStopConsolidatorServiceServer interface {
	mustEmbedUnimplementedStopConsolidatorServiceServer()
}

func RegisterStopConsolidatorServiceServer(s grpc.ServiceRegistrar, srv StopConsolidatorServiceServer) {
	// If the following call pancis, it indicates UnimplementedStopConsolidatorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StopConsolidatorService_ServiceDesc, srv)
}

func _StopConsolidatorService_StopConsolidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopConsolidatorServiceServer).StopConsolidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopConsolidatorService_StopConsolidator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopConsolidatorServiceServer).StopConsolidator(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// StopConsolidatorService_ServiceDesc is the grpc.ServiceDesc for StopConsolidatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StopConsolidatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.StopConsolidatorService",
	HandlerType: (*StopConsolidatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StopConsolidator",
			Handler:    _StopConsolidatorService_StopConsolidator_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
